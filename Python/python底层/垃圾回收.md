- [python有GIL，java/cpp没有](#python有giljavacpp没有)
- [Java的垃圾回收](#java的垃圾回收)
  - [触发垃圾回收的条件](#触发垃圾回收的条件)
  - [GC方式](#gc方式)
    - [如何判断是垃圾](#如何判断是垃圾)
  - [GC算法](#gc算法)
- [python 垃圾回收](#python-垃圾回收)
  - [对象存放](#对象存放)
    - [计数器增加](#计数器增加)
    - [计数器减小](#计数器减小)
    - [循环引用](#循环引用)
  - [可达性分析 --\> 标记清除\&分代回收](#可达性分析----标记清除分代回收)
    - [实现原理](#实现原理)
    - [可达性分析 -- 标记清除](#可达性分析----标记清除)
    - [分代回收](#分代回收)
- [缓存机制](#缓存机制)
  - [池](#池)
  - [free\_list](#free_list)
  - [析构函数](#析构函数)

# python有GIL，java/cpp没有

python 的垃圾回收机制 ：引用计数，无法保证多线程下的线程安全，说白了就是无法多线程操作一个对象，因此引入GIL全局解释器锁

CPython采用的引用计数是最朴素的实现方式：局部变量、全局变量和对象字段都参与到引用计数中，而且引用计数的更新是在锁下同步的；外加朴素的mark-sweep备份来处理循环引用。

目前JVM最主要的实现HotSpot VM中没有使用GIL，而是在VM内使用了一系列细粒度锁来实现VM内各种功能分别的同步需求。但其实HotSpot VM源自一个名为Strongtalk的Smalltalk VM，在Stongtalk VM以及最早期的HotSpot VM中是有GIL的，**通过多年的努力研发才把它替换为细粒度锁**。

C++语言没有GIL。C++的语言功能中也没有什么需要用一把全局大锁来总控的功能，所以实现中也没有C++ runtime library用“GIL”的（虽然有通过解释器实现的C++，所以这个“I”在这些实现里也算是成立把，但没有GIL）。

# Java的垃圾回收

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202404081122946.png)

## 触发垃圾回收的条件

- 当没有线程在运行时，垃圾回收会被调用。因为垃圾回收在优先级最低的线程中进行，当应用忙时，垃圾回收不被调用（不是由程序员自己调用的），但除第二点
- 堆内存不足时会触发垃圾回收机制

## GC方式

### 如何判断是垃圾

- 引用计数法
- 可达性分析（根搜索法）** jVM用了这个**

一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。更准确的说，一个对象只有满足下述两个条件之一，就会被判断为可达的：

- 对象是属于根集中的对象  
对象被一个可达的对象引用

## GC算法

在判断了该对象是垃圾之后，需要用算法进行回收

标记-清除、标记-整理、复制、分代

# python 垃圾回收

**引用计数为主，以标记-清除（可达性分析（根搜索法）判定是否是垃圾）来解决循环引用问题，
为避免标记-清除带来的全堆内存扫描的耗损，采用分代回收，0代达到一定数量，扫描一次，0代扫描了多少次，1代扫描一次，以此类推（只扫描特定区域（代）**

## 对象存放

在python程序中，创建的任何对象都会放在refchain的双向链表中

name = "小猪佩奇"     创建这个对象时，内部会创建一些数据，并且打包在一起 

哪些数据：【指向上一个对象的指针、指向下一个对象的指针、类型(这里为字符串)、引用的个数】 PyObject/PyVarObject

引用的个数:

比如 name = '小猪佩奇' ,会给“小猪佩奇”开辟一个内存空间用来存放到双向链表中。

这时候如果有 new = name，不会创建两个“小猪佩奇”，而是将new指向之前的那个小猪佩奇，而引用的个数变为2，也就是"小猪佩奇"这个对象被引用了两次。


age = 18  内部会创建一些数据，【**指向上一个对象的指针、指向下一个对象的指针、类型、引用的个数、val=18**】


hobby = ["抽烟","喝酒","烫头"]   内部会创建一些数据，【指向上一个对象的指针、指向下一个对象的指针、类型、引用的个数、items=元素、元素的个数】

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202404081128393.png)

在C源码中有两个关键的结构体：PyObject、PyvarObject

- PyObject（存储是上一个对象，下一个对象，类型，引用的个数，是每一个对象都具有的）。
- PyvarObject（存储的是由多个元素组成的类型数据具有的值，例如字符串，int）

当python程序运行时，会根据数据类型的不同，找到其对应的结构体，根据结构体中的字段，来进行创建相关的数据，然后将对象添加到refchain双向链表中。

```C
#define PyObject_HEAD       PyObject ob_base ;
#define PyObject_VAR_HEAD       PyVarObject ob_base;

//宏定义，包含上一个、下一个，用于构造双向链表用。(放到refchain链表中时，要用到)
#define _PyObject_HEAD_EXTRA            
    struct _object *_ob_next;           
    struct _object *_ob_prev;
    
typedef struct _object {
    _PyObject_HEAD_EXTRA            //用于构造双向链表
    Py_ssize_t ob_refcnt;           //引用计数器
    struct _typeobject *ob_type;    //数据类型
} PyObject;
typedef struct {
    PyObject ob_base;       // PyObject对象
    Py_ssize_t ob_size; /* Number of items in variable part, 即:元素个数*/
} PyVarObject;

```

### 计数器增加


当发生以下四种情况的时候，该对象的引用计数器**+1：**

```Python
a=14  # 对象被创建  
b=a   # 对象被引用 
func(a)   # 对象被作为参数,传到函数中
List=[a,"a","b",2]   # 对象作为一个元素，存储在容器中  
b = 9999 # 引用计数器的值为1
c = b  # 引用计数器的值为2
```

### 计数器减小


当发生以下四种情况时，该对象的引用计数器**-1**

```python
当该对象的别名被显式销毁时        del a
当该对象的引别名被赋予新的对象，   a=26
一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
将该元素从容器中删除时，或者容器被销毁时。
a = 999
b = a  # 当前计数器为2
del b # 删除变量b：b对应的对象的引用计数器-1   （此时计数器为1）
del a # 删除变量a：a对应的对象的引用计数器-1    (此时引用计数器为0)
```

当引用计数器为0 时，意味着没有人再使用这个对象，这个对象就变成垃圾，垃圾回收。

回收： 回收不等于销毁

1.对象从refchain的链表移除。  当我们将"雷霆嘎巴"的对象的引用计数器减小至0时，就将其移除，并且相邻两边直接连接。

2.将对象进行销毁，内存归还给操作系统，可用内存就增加。

### 循环引用

一种编程语言利用引用计数器实现垃圾管理和回收，已经是比较完美的了，只要计数器为0就回收，不为0就不回收，即简单明了，又能实现垃圾管理。但是如果真正这样想就太单纯了，因为，仅仅利用引用计数器实现垃圾管理和回收，就会存在一个BUG，就是循环引用问题。

```python
v1 = [1,2,3]        # refchain中创建一个列表对象，由于v1=对象，所以列表引对象用计数器为1.
v2 = [4,5,6]        # refchain中再创建一个列表对象，因v2=对象，所以列表对象引用计数器为1.
v1.append(v2)        # 把v2追加到v1中，则v2对应的[4,5,6]对象的引用计数器加1，最终为2.
v2.append(v1)        # 把v1追加到v2中，则v1对应的[1,2,3]对象的引用计数器加1，最终为2.

del v1    # 引用计数器-1
del v2    # 引用计数器-1
```

两个引用计数器现在都是1，那么它们都不是垃圾所以都不会被回收，但如果是这样的话，我们的代码就会出现问题。

我们删除了v1和v2，那么就没有任何变量指向这两个列表，那么这两个列表之后程序运行的时候都无法再使用，但是这两个列表的引用计数器都不为0，所以不会被当成垃圾进行回收，所以这两个列表就会一直存在在我们的内存中，永远不会销毁，当这种代码越来越多时，我们的程序一直运行，内存就会一点一点被消耗，然后内存变满，满了之后就爆栈了。这时候如果重新启动程序或者电脑，这时候程序又会正常运行，其实这就是因为循环引用导致数据没有被及时的销毁导致了内存泄漏。

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202404081133270.png)


## 可达性分析 --> 标记清除&分代回收

在python中对于那些可以有多个元素组成的对象，可能会存在循环引用的问题，并且为了解决这个问题，python又引入了标记清除和分代回收。

**标记清楚也是采用可达性分析（根搜索法）来确定是不是垃圾，进而进行GC**

在python中对于那些可以有多个元素组成的对象，可能会存在循环引用的问题，并且为了解决这个问题，python又引入了标记清除和分代回收。

**标记清楚也是采用可达性分析（根搜索法）来确定是不是垃圾，进而进行GC**

### 实现原理

在python的底层中，再去维护一个链表，这个链表中专门放那些可能存在循环引用的对象。那么哪些情况可能导致循环引用的情况发生？就是那些元素里面可以存放其他元素的元素。（list/dict/tuple/set，甚至class）

第一个链表refchain采用引用计数

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202404081141615.png)

第二个链表采用可达性分析-->标记清除

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202404081141186.png)

### 可达性分析 -- 标记清除

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

下图中，我们把小黑点视为全局变量，也就是把它作为root object，从小黑点出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。

- 寻找跟对象（root object）的集合作为垃圾检测动作的起点，根对象也就是一些全局引用和函数栈中的引用，这些引用所指向的对象是不可被删除的。上面循环引用的v1、v2就是不可达对象；
- 从root object集合出发，沿着root object集合中的每一个引用，如果能够到达某个对象，则说明这个对象是可达的，那么就不会被删除，这个过程就是垃圾检测阶段。
- 当检测阶段结束以后，所有的对象就分成可达和不可达两部分，所有的可达对象都进行保留，其它的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是链表将这些集合的对象连接在一起）

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202404081401736.png)

### 分代回收

将第二个链表（可能存在循环引用的链表），维护成3个环状双向的链表：

- 0代： 0代中对象个数达到700个，扫描一次。
- 1代： 0代扫描10次，则1代扫描1次。
- 2代： 1代扫描10次，则2代扫描1次。

当我们创建一个对象val = 19,那么它只会加到refchain链表中。

当我们创建一个对象v1 = [11,22],除了加到refchain，那么它会加到0代链表中去。

如果再创建一个对象v2 = [33,44],那么它还是往0代添加。

直到0代中的个数达到700之后，就会对0代中的所有元素进行一次扫描，扫描时如果检测出是循环引用，那么引用计数器就自动-1，然后判断引用计数器是否为0，如果为0，则为垃圾就进行回收。不是垃圾的话，就对该数据进行升级，从0代升级到1代，这个时候0代就是空，1代就会记录一下0代已经扫描1次，然后再往0代中添加对象直到700再进行一次扫描，不停反复，直到0代扫描了10次，才会对1代进行1次扫描。


# 缓存机制

## 池

- -5、-4、…… 、256，bool、一定规则的字符串，这些值都是常用的值，所以就会在内存中帮你先把这些值先创建好
- int(float)：**任何数字**在同一代码块下都会复用。（自动缓存）
- bool：True和False在字典中会以**1，0**方式存在，并且复用。
- str：**几乎所有的字符串**都会符合字符串驻留机制

```python
'''不可变的'''
a = 1
b = 1
c = a
print(id(a), id(b), id(c))    # 9594664 9594664 9594664
a = 2
print(a, b ,c) # 2,1,1
print(id(a), id(b), id(c)) # 9594696 9594664 9594664

a = 100000
b = 100000
print(id(a), id(b)) # 281473294702544 281473294702544
b = 100002
print(id(a), id(b))    # 281473294702544 281473287518352

'''可变的'''
b = [1, 2, 3]
a = b  # a 和 b 指向同一个列表对象
print(a)  # 输出: [1, 2, 3]
print(b)  # 输出: [1, 2, 3]

# 修改 a 所指向的对象
a.append(4)
print(a)  # 输出: [1, 2, 3, 4]
print(b)  # 输出: [1, 2, 3, 4]，b 也被修改了

```

## free_list

**当一个对象的引用计数器为0的时候，按理说应该回收，但是在python内部为了优化，不会去回收，而是将对象添加到free_list链表中当作缓存。以后再去创建对象时就不再重新开辟内存，而是直接使用free_list。**

但是free_list也是有容量的，不是无限收纳, 假设默认数量为80，只有当free_list满的时候，才会直接去销毁。  

代表性的有float/list/tuple/dict，这些数据类型都是以free_list方式来进行回收的。

- int、float、str对象只会放到refchain中，ob_refcnt=0，放到free_list中（未满），free_list满了销毁。
- dict、list、set、tuple对像会放到refchain中（会产生循环引用的对象），以及0代，ob_refcnt=0，放到free_list中（未满），free_list满了销毁。

## 析构函数

类会默认有一个析构函数，GC时会被主动调用

`'''`

  `del析构函数，并不是在del a对象的时候就会调用该析构函数`

  `只有当该对象的引用计数为0时才会调用析构函数，回收资源`

  `析构函数被python的垃圾回收器销毁的时候调用。当某一个对象没有被引用时，垃圾回收器自动回收资源，调用析构函数`

`'''`

```Python
class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print class_name, "销毁"
 
pt1 = Point()
pt2 = pt1
pt3 = pt1
print id(pt1), id(pt2), id(pt3) # 打印对象的id
del pt1
del pt2
del pt3

```