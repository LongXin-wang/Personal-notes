- [一次请求全过程](#一次请求全过程)
  - [NAT转换 - 请求/响应达到局域网，确定是给局域网的用户A而非用户B](#nat转换---请求响应达到局域网确定是给局域网的用户a而非用户b)
  - [ARP - 根据IP确定MAC地址](#arp---根据ip确定mac地址)
    - [同一个网络下](#同一个网络下)
    - [不再同一网络下](#不再同一网络下)
- [应用层](#应用层)
  - [HTTP](#http)
      - [http常见字段](#http常见字段)
  - [http发展](#http发展)
    - [http1.1](#http11)
    - [http2](#http2)
  - [http缓存](#http缓存)
    - [强制缓存](#强制缓存)
    - [协商缓存](#协商缓存)
  - [http相应问题的处理](#http相应问题的处理)
    - [传输大文件](#传输大文件)
      - [数据压缩](#数据压缩)
      - [分块传输](#分块传输)
      - [范围请求](#范围请求)
  - [加密\&签名\&摘要](#加密签名摘要)
    - [加密方式](#加密方式)
      - [对称加密](#对称加密)
      - [非对称加密](#非对称加密)
      - [混合加密](#混合加密)
    - [摘要](#摘要)
    - [数字签名](#数字签名)
- [传输层](#传输层)
  - [TCP](#tcp)
    - [三次握手，四次挥手](#三次握手四次挥手)
    - [拥塞模型](#拥塞模型)
  - [UDP](#udp)
- [网络层](#网络层)
  - [IP](#ip)
  - [端口号](#端口号)
  - [ICMP与ping](#icmp与ping)
    - [ping的过程](#ping的过程)
- [数据链路层](#数据链路层)
  - [数据传输协议](#数据传输协议)

# 一次请求全过程

URL解析--> DNS查询-->TCP连接-->处理请求-->接受响应-->渲染页面

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291005277.png)

1. URL解析：浏览器对网址进行格式化检查，确认是有效网址，如果没有给定什么协议，会默认是http协议。协议 + 服务器 + 文件路径名
2. DNS查询：根据DNS查询IP地址的过程【浏览器缓存，操作系统缓存，路由器缓存，本地域名服务器缓存，根域名】一级一级向上问路
3. 协议栈：通过 DNS 获取到 IP地址 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。
4. 建立TCP连接：三次握手
5. 加上IP首部：TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。
6. 加上MAC头部：生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。
7. 网卡出口：IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。
8. 将包通过交换机传输：交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。
9. 通过路由器传输：网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。
10. 数据报抵达服务器后，要拆解数据包
11. 服务器响应请求：解析请求，生成响应头和具体响应内容，2开头的是正常。3开头表示重定向，4开头是客户端错误，5开头表示服务器错误
12. 浏览器解析：根据不同的响应状态码来做不同的事情
13. 浏览器渲染页面：浏览器显示HTML，浏览器向服务器发送请求获取嵌入在HTML中的对象，浏览器发送异步请求
14. 关闭TCP连接：根据连接属性判断是否断开连接。四次挥手。

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291006532.png)

- 物理地址Mac决定了下一站的位置，IP地址决定了最后的接收方是谁, 从发送方传输到接收方，中间需要经过很多次的中转站，这些中转站需要使用Mac地址进行标记。
- MAC地址随着每一跳不断变化，IP地址（起始公网IP）则不变（保存在数据包中）
- TCP有源端口号和目的端口号，来确认是给哪个应用的；
- 其实我们服务确定IP地址，都是确定发送方的公网IP（WAN广域网），比如光猫的IP（即运营商分配的公网IP），不会是用户ip的（这是LAN局域网）
- 猫和路由器：光猫（运营商分配的公网ip—>内网ip192.168.1.1）--路由器（192.168.2.1，分配192.168.2.100-192.168.2.199给用户）
- NAT 决定给局域网的用户A而非用户B

## NAT转换 - 请求/响应达到局域网，确定是给局域网的用户A而非用户B

私有网对外访问或接受请求时，将IP包中的源IP或者目标IP转化成公有IP

- 如果单纯靠IP转换，用户A和用户B同时发送了，那server就返回的时候就不知道给谁了
- 如下图：192.168.1.2访问NAT转换时加上4096端口，192.168.1.3访问NAT转换时加上4097端口，以作区分；

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291007948.png)

## ARP - 根据IP确定MAC地址

### 同一个网络下

源IP和源MAC不变，ARP根据目标IP去广播询问目标MAC地址，由于在一个网络下（子网掩码），可以直接把目标MAC告诉ARP

### 不再同一网络下

A -- 网关1 -- 网关2 -- B

主机A给主机B发送数据，发现是不同网段的数据通信，而我本地是没有这个关于B的ARP映射关系的，就会发送一个arp请求报文，解析网关MAC地址

路径：

源IP和源MAC是A的，目的IP是B的，目的MAC是网关1的，由此到达网关1；  
源IP是A的，源MAC是网关1的， 目的IP是B的，目的MAC是网关2的，由此到达网关2；  
源IP是A的，源MAC是网关2的，目的IP是B的，目的MAC是B的，到达B；  
源IP是B的和MAC是B的，目的IP是A，目的MAC是网关2，到达网关2；  
源IP是B的，源MAC是网关2的，目的IP是A，目的MAC是网关1的，到达网关1；  
源IP是B的，源MAC是网关1的，目的IP是A，目的MAC是A，到达A

# 应用层

## HTTP

所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”（页面里的请求），形成复杂的非线性、网状的结构关系。

1. 互联网上绝大部分资源都使用 HTTP 协议传输；
2. 浏览器是 HTTP 协议里的请求方，即 User Agent；
3. 服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；
4. CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；
5. 爬虫是另一类 User Agent，是自动访问网络资源的程序。

#### http常见字段

```bash
Host: www.A.com  

Content-Length: 1000   #本次回应的数据长度。字节

Connection: Keep-Alive  #保持长链接。连接就不会中断，保持连接（除非一段明确断开）。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。

Content-Type: text/html; Charset=utf-8   #告诉客户端，本次数据是什么格式

Accept: */*   #客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。 application/json, text/plain, */*

Accept-Encoding: gzip/deflate/br

Content-Encoding: gzip   #服务器返回的数据使用了什么压缩格式

```

## http发展

### http1.1

- 缓存技术
- 压缩资源
- 长连接&管道化，即可以在一个 http 连接上传输多个请求&响应（http1.1 之前每个 http 链接只可以传输一对请求&响应然后就断开链接）。在没有管道化的情况下，一个连接上的下一个请求需要在前一个响应返回后再发出，而有管道化，一个链接的请求可以接着发送，不需要等待上一个请求响应再发送

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291353681.png)

### http2

- 新的二进制格式，HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。
- header压缩，在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。
- 服务端推送，主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。
- 并发传输，在HTTP/1.1中，为了减少建立和关闭连接的开销，引入了长连接（Keep-Alive），即在单个TCP连接上可以传输多个HTTP请求和响应，避免了每次请求都建立新的TCP连接，但仍然存在队头阻塞问题，即如果某个请求响应较慢，将会影响到后续请求的响应时间。相比之下，HTTP/2通过**多路复用**（Multiplexing）的方式在单个连接上同时传输多个请求和响应，解决了HTTP/1.1的队头阻塞问题。在HTTP/2中，请求和响应被分割为一个或多个帧（Frame），这些帧可以交错发送和重新组装，这样就可以充分利用连接的带宽，提高传输效率

## http缓存

### 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

HTTP 响应头部同时有 Cache-Control（相对时间） 和 Expires（绝对时间） 字段的话，Cache-Control 的优先级高于 Expires 

### 协商缓存

某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存

## http相应问题的处理

### 传输大文件

#### 数据压缩

通常浏览器在发送请求时都会带着“**Accept-Encoding**”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“**Content-Encoding**”响应头里，再把原数据压缩后发给浏览器。

不过这个解决方法也有个缺点，gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。

不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。

#### 分块传输

这种“**化整为零**”的思路在 HTTP 协议里就是“**chunked**”分块传输编码，在响应报文里用头字段“**Transfer-Encoding: chunked**”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

“Transfer-Encoding: chunked”和“Content-Length”这两个字段是**互斥的**，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。

#### 范围请求

比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。

HTTP 协议为了满足这样的需求，提出了“**范围请求**”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是**客户端的“化整为零”**。

范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。

请求头**Range**是 HTTP 范围请求的专用字段，格式是“**bytes=x-y**”，其中的 x 和 y 是以字节为单位的数据范围。

要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。

Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：

- “0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；
- “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；
- “-1”是文档的最后一个字节，相当于“99-99”；
- “-10”是从文档末尾倒数 10 个字节，相当于“90-99”。

## 加密&签名&摘要

### 加密方式

#### 对称加密

TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。 需要会话密钥

#### 非对称加密

RSA  
它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。

#### 混合加密

使用对称加密会对称密钥泄露，使用非对称加密太慢

非对称加密交互对称加密的密钥，而后就用对称加密

这就是现在 TLS 里使用的**混合加密**方式，其实说穿了也很简单：

在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。

然后用随机数产生对称算法使用的“**会话密钥**”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。

对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。


### 摘要

你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。

比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。

不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。

### 数字签名

摘要传过去了，可以保证完整性，但是中间黑客把明文和摘要一起改了，也能保证完整性，我们也不得而知；所以你需要用数字签名，将 摘要 签名，这样，到对方的时候可以将签名解开，比较解开的摘要和传过去的摘要是否一致，保证安全性

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291423515.png)

> 有签名了就不需要单独传摘要了，签名就是摘要的加密，传过去先解密获得摘要，然后那边比较摘要是否一致就行

# 传输层

## TCP

### 三次握手，四次挥手
 
三次握手，确认对方发送接受正常，自己发送接受正常

三次握手的最主要目的是「双方确认自己与对方的发送与接收是正常的」。

第一次握手：Client什么都不能确认；Server确认了对方发送正常。

第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接受正常，对方发送正常。

第三次握手：Client确认了：自己发送、接受正常，对方发送，接受正常；Server确认了：自己发送了、接受正常，对方发送、接受正常。

所以三次握手就能确认双方收发功能是否正常。

四次挥手

Client：我已经说完了。

Server：我收到了，等等我，我还没说完。

Server：好了，我也说完了。

Client：好的，那我们通信结束。

### 拥塞模型

初始窗口是拥塞算法的核心，这表示的是最开始发送多少数据包。

拥塞机制的另一个核心组件是慢启动。什么意思呢？就是我们的服务器，它发送两个完整的MSS到客户端，然后从客户端收到确认，整个过程很顺畅。然后再测量一下在发送数据和接收确认之间的等待时间，服务器会认为整个流程没有问题。之后服务器会将下次发送的MSS数量翻倍，，它将在下一次发送四个MSS，然后等待这些确认返回。重复上面流程，如果还是很顺畅，会继续的将发出的数据包数量加倍。这是一种常见的机制，你会在Reno和NewReno等一些较旧的算法中看到这种机制。

## UDP

无状态、无连接

UDP包头的时候，发现的确有端口号，有源端口号和目标端口号。

UDP简单、处理速度快，不像TCP那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而TCP在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。



# 网络层

## IP

子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。子网掩码为确定访问的IP是不是再同一个局域网下

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291518665.png)

## 端口号

端口号的范围从0到65535，通过端口号被分为三个不同的类别。

- 公认端口（Well-Known）0-1023 http80 https443 ssh22
- 注册端口（Registered）1024-49151 mysql 3306
- 临时端口（Ephemeral）49152-65535

## ICMP与ping

ICMP相当于网络世界的侦察兵。两种类型的ICMP报文，一种是主动探查的查询报文，一种异常报告的差错报文；

### ping的过程

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401291903060.png)

# 数据链路层

## 数据传输协议

（1）首先，每次发送方都只发一个数据分组，接收方对数据分组进行差错检测，检验是否有误码。如果没有误码，那么给发送方发送ACK确认分组；如果有误码，则丢弃分组，并给发送方发送NAK否认分组；

（2）超时重传，发送方仍收不到接收方的ACK或NAK，则重传原来的数据分组

（3）已经传过的，重传忽略：给发送方发送的消息和接受方发送的ACK进行编号

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401301405677.png)

