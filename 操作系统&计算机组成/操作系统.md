- [Linux设计](#linux设计)
  - [\*Multitask and SMP（Symmetric multiprocessing）](#multitask-and-smpsymmetric-multiprocessing)
  - [Monolithic Kernel](#monolithic-kernel)
- [线程模型](#线程模型)
  - [进程和线程](#进程和线程)
    - [用户态线程和内核态线程的映射](#用户态线程和内核态线程的映射)
  - [线程调度](#线程调度)
    - [先到先服务](#先到先服务)
    - [短作业优先](#短作业优先)
    - [优先级队列](#优先级队列)
    - [抢占](#抢占)
- [原子\&竞争条件](#原子竞争条件)
  - [原子操作--\>竞争条件](#原子操作--竞争条件)
  - [解决竞争条件](#解决竞争条件)
    - [避免临界区 - ThreadLocal](#避免临界区---threadlocal)
    - [cas 指令\& tas 指令](#cas-指令-tas-指令)
    - [设置为原子操作](#设置为原子操作)
      - [锁](#锁)
- [进程/线程间通信](#进程线程间通信)
  - [进程通信](#进程通信)
    - [管道](#管道)
    - [消息队列](#消息队列)
    - [信号量](#信号量)
    - [socket](#socket)
  - [线程通信](#线程通信)
    - [共享变量](#共享变量)
    - [锁机制](#锁机制)

# Linux设计

对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：

- 管理进程、线程（决定哪个进程、线程使用 CPU）；
- 管理内存（决定内存用来做什么）；
- 连接硬件设备（为进程、和设备间提供通信能力）；
- 提供系统调用（接收进程发送来的系统调用）

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401261054470.png)

## *Multitask and SMP（Symmetric multiprocessing）

**MultiTask 指多任务**，Linux 是一个多任务的操作系统。多任务就是多个任务可以同时执行，这里的“同时”并不是要求并发，而是在一段时间内可以执行多个任务。当然 Linux 支持并发。

**SMP 指对称多处理**。其实是说 Linux 下每个处理器的地位是相等的，内存对多个处理器来说是共享的，每个处理器都可以访问完整的内存和硬件资源。 这个特点决定了在 Linux 上不会存在一个特定的处理器处理用户程序或者内核程序，它们可以被分配到任何一个处理器上执行。

## Monolithic Kernel

这个名词翻译过来就是宏内核，宏内核反义词就是 Microkernel ，微内核的意思。Linux 是宏内核架构，这说明 Linux 的内核是一个完整的可执行程序，且内核用最高权限来运行。宏内核的特点就是有很多程序会打包在内核中，比如，文件系统、驱动、内存管理等。当然这并不是说，每次安装驱动都需要重新编译内核，现在 Linux 也可以动态加载内核模块。所以哪些模块在内核层，哪些模块在用户层，这是一种系统层的拆分，并不是很强的物理隔离。

与宏内核对应，接下来说说微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的。

也就是说微内核只保留基本能力，很多放到了用户态

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401261002436.png)

# 线程模型

## 进程和线程

一个应用程序启动后会在内存中创建一个执行副本，这就是**进程**。Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。

进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。

程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。

一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。

### 用户态线程和内核态线程的映射

线程简单理解，就是要执行一段程序。程序不会自发的执行，需要操作系统进行调度。**我们思考这样一个问题，如果有一个用户态的进程，它下面有多个线程。如果这个进程想要执行下面的某一个线程，应该如何做呢**？

这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 CPU 的执行资源。线程映射，不一定一对一，几个用户态线程映射到一个内核态线程

如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。

这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。

## 线程调度

### 先到先服务

作队列的数据结构，具有先入先出（First In First Out，FIFO）性质。先进入队列的作业，先处理，因此从公平性来说，这个算法非常朴素。另外，一个作业完全完成才会进入下一个作业，作业之间不会发生切换，从吞吐量上说，是最优的——因为没有额外开销。

### 短作业优先

通常会同时考虑到来顺序和作业预估时间的长短，优先处理时间短的（小于平均等待时间）

### 优先级队列

**解决：紧急插队任务&等待太久的任务**

优先级队列的一种实现方法就是用到了堆（Heap）这种数据结构，更最简单的实现方法，就是每次扫描一遍整个队列找到优先级最高的任务。也就是说，堆（Heap）可以帮助你在 O(1) 的时间复杂度内查找到最大优先级的元素。

### 抢占

**解决：执行大任务的时候来了小任务**

抢占就是把执行能力分时，分成时间片段。 让每个任务都执行一个时间片段。如果在时间片段内，任务完成，那么就调度下一个任务。如果任务没有执行完成，则中断任务，让任务重新排队，调度下一个任务。





# 原子&竞争条件

## 原子操作-->竞争条件

要想弄清楚锁，就要弄清楚锁的实现，实现锁需要底层提供的原子操作，因此我们先来学习下原子操作。

原子操作就是操作不可分。在多线程环境，一个原子操作的执行过程无法被中断。那么你可以思考下，具体原子操作的一个示例。

比如`i++`就不是一个原子操作，因为它是 3 个原子操作组合而成的：

1. 读取 i 的值；
2. 计算 i+1；
3. 写入新的值。

像这样的操作，在多线程 + 多核环境会造成**竞争条件**。

## 解决竞争条件

解决竞争条件有很多方案，一种方案就是不要让程序同时进入临界区，这个方案叫作**互斥**。还有一些方案旨在避免竞争条件，比如 ThreadLocal、 cas 指令及乐观锁

### 避免临界区 - ThreadLocal

不让程序同时进入临界区这个方案比较简单，核心就是我们给每个线程一个变量`i`，比如利用 ThreadLocal，这样线程之间就不存在竞争关系了。这样做优点很明显，缺点就是并不是所有的情况都允许你这样做。有一些资源是需要共享的，比如一个聊天室，如果每次用户请求都有一个单独的线程在处理，不可能为每个请求（线程）都维护一份聊天记录。

### cas 指令& tas 指令

另一个方案是利用 CPU 的指令，让`i++`成为一个原子操作。 很多 CPU 都提供 Compare And Swap 指令。这个指令的作用是更新一个内存地址的值，比如把`i`更新为`i+1`，但是这个指令明确要求使用者必须确定知道内存地址中的值是多少。比如一个线程想把`i`从`100`更新到`101`，线程必须明确地知道现在`i`是 100，否则就会更新失败。

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202401261043715.png)

还有一个方案是 tas 指令，有的 CPU 没有提供 cas（大部分服务器是提供的），提供一种 Test-And-Set 指令（tas）。tas 指令的目标是设置一个内存地址的值为 1，它的工作原理和 cas 相似。首先比较内存地址的数据和 1 的值，如果内存地址是 0，那么把这个地址置 1。如果是 1，那么失败。


### 设置为原子操作

利用lua脚本实现

#### 锁

锁（lock），目标是实现抢占（preempt）。就是只让给定数量的线程进入临界区。锁可以用`tas`或者`cas`来实现。

说到并发场景，设计系统的目的往往是达到同步（Synchronized）的状态，同步就是大家最终对数据的理解达成了一致。

同步的一种方式，就是让**临界区**互斥。 这种方式，每次只有一个线程可以进入临界区。比如多个人修改一篇文章，这意味着必须等一个人编辑完，另一个人才能编辑。但是从实际问题出发，如果多个人编辑的不是文章的同一部分，是可以同时编辑的。因此，让临界区互斥的方法（对临界区上锁），具有强烈的排他性，对修改持保守态度，我们称为**悲观锁（Pressimistic Lock）**。

通常意义上，我们说上锁，就是悲观锁，比如说 MySQL 的表锁、行锁、Java 的锁，本质是互斥（mutex）。

和**悲观锁（PressimisticLock）持相反意见的，是乐观锁（Optimistic Lock）**。你每天都用的，基于乐观锁的应用就是版本控制工具 Git。Git 允许大家一起编辑，将结果先存在本地，然后都可以向远程仓库提交，如果没有版本冲突，就可以提交上去。这就是一种典型的乐观锁的场景，或者称为基于版本控制的场景。

# 进程/线程间通信

## 进程通信

### 管道

道提供了一种非常重要的能力，就是组织计算。进程不用知道有管道存在，因此管道的设计是非侵入的。程序员可以先着重在程序本身的设计，只需要预留响应管道的接口，就可以利用管道的能力。比如用`shell`执行MySQL语句，可能会这样：

  进程1 | 进程2 | 进程3 | mysql -u... -p | 爬虫进程

我们可以由进程 1、进程 2、进程 3 计算出 MySQL 需要的语句，然后直接通过管道执行。MySQL经过计算将结果传给一个爬虫进程，爬虫就开始工作。MySQL并不是设计用于管道，爬虫进程也不是设计专门用于管道，只是程序员恰巧发现可以这样用，完美地解决了自己的问题，比如：用管道构建一个微型爬虫然后把结果入库。

我们还学过一个词叫作**命名管道**。命名管道并没有改变管道的用法。相比匿名管道，命名管道提供了更多的编程手段。比如：

  进程1 > namedpipe

  进程2 > namedpipe

上面的程序将两个进程的临时结果都同时重定向到 namedpipe，相当于把内容合并了再找机会处理。再比如说，你的进程要不断查询本地的 MySQL，也可以考虑用命名管道将查询传递给 MySQL，再用另一个命名管道传递回来。这样可以省去和 localhost 建立 TCP 3 次握手的时间。 当然，现在数据库都是远程的了，这里只是一个例子。

### 消息队列

是消息的链接表，存放在内核中。特点是容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题

### 信号量

比如有10个信号量，100个进程来抢，抢到的10个能去获取资源，有点类似限流

与已经介绍过的`IPC`结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
特点是不能传递复杂消息，只能用来同步。

指两个或多个进程共享一个给定的存储区。是最快的一种`IPC`，因为进程是直接对内存进行存取。信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
特点是能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

### socket

`socket`一般指套接字。所谓套接字`(Socket)`，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。
特点是`I/O`复用提供一种能力，这种能力使得当一个`I/O`条件满足时，进程能够及时得到这个信息。适合（远程过程调用、集群）。

## 线程通信

### 共享变量

同一进程下的线程共享全局变量、静态变量等数据。线程之间的通信更方便。

### 锁机制

- 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。
- 读写锁：允许多个线程同时读共享数据，而对写操作互斥。
- 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。

