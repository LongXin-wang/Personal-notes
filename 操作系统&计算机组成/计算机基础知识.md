
# 编码格式

- ASCII字符集 -- ASCII编码 （一个字节：英文字母、数字、符号）
- GBK字符集 -- GBK编码 （2个字节）
- Unicode字符集 -- UTF8、UTF16、UTF32编码

## 存储文件

文本文件：对于文本文件，可以直接将其内容转换为字符串，然后序列化成二进制，以便进行存储和传输。

二进制文件：对于图片、视频、音频等二进制文件，通常会直接以二进制形式进行存储，而不需要转换为字符串。

数据库存储：在数据库中，文件可以以二进制形式直接存储，而无需转换为字符串。

序列化：在某些情况下，需要对对象进行序列化，这时会将对象转换为二进制形式，而不一定需要转换为字符串

## 编码、解码

都是二进制编码格式

### ASCII

最早 ASCII 只定义了128个字符编码，包括96个文字和32个控制符号，一共128个字符只需要一个字节的7位就能表示所有的字符，因此 ASCII 只使用了一个字节的后7位，剩下最高位1比特被用作一些通讯系统的奇偶校验

### UTF8

英文1字节，汉字3字节

```python
s = 'Hello, world!'
b = s.encode('ascii')
print(b)  # b'Hello, world!'

s = 'Hello, 世界!'
b = s.encode('utf-8')
print(b)  # b'Hello, \xe4\xb8\x96\xe7\x95\x8c!' python转化为字节输出了（16进制）
b = s.encode('utf-16')
print(b)  # b'Hello, \xe4\xb8\x96\xe7\x95\x8c!'
b = s.encode('ascii') # 报错，asciib不支持中文

print(len(b'Hello, \xe4\xb8\x96\xe7\x95\x8c!'))  # 14
print(len(b'Hello, world!'))  # 13 = 12 + 1空格
```

## 二进制编码

>无论哪种编码格式，传输都要转成二进制编码；将某个字符或字符串转换为UTF-8编码时，实际上就是将其转换为二进制编码的一种方式

**数字转二进制，可以用整数表示法，汉字/英文等转二进制，有对应的二进制表示，ascii码那部分就用ascii码表示就行**

>在 ASCII 码里面，数字 9 和整数表示法里一样，用 0000 1001 来表示。字符串 15 也不是用 0000 1111 这 8 位来表示，而是变成两个字符 1 和 5 连续放在一起，也就是 0000 0001 和 0000 0101，需要用两个 8 位来表示。

>我们可以看到，最大的 32 位整数，就是 2147483647。如果用整数表示法，只需要 32 位就能表示了。但是如果用字符串来表示，一共有 10 个字符，每个字符用 8 位的话，需要整整 80 位。比起整数表示法，要多占很多空间。

## 浮点数

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202402041018403.png)

# 语言运行机制

## C/CPP

C源文件通过预处理、编译、汇编、链接，最终机器执行目标代码（二进制）

- 预处理：主要处理以下指令：宏定义指令，条件编译指令，头文件包含指令。 预处理所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令，头文件都被展开（递归展开）的文件；
- 编译：将源代码转为汇编代码（机器不会识别汇编代码）；（***.S）
- 汇编：生成的汇编代码翻译成符合一定格式的机器代码（二进制）；(***.O)
- 链接：简单理解为两个作用，一是修改目标文件中的信息，对地址做重定位，二是把多个目标文件合并成一个可执行文件；(***.out)
- 执行：机器识别二进制（这个都知道吧..），机器直接跑二进制；

## Java

JDK: JRE+编译器（javac）+调试器+....

JRE ：JVM+库函数+运行java必须的文件+....

先编译后解释运行

```Mermaid
flowchart LR
      A([源文件*.java])-->B[java编译器javac]
      B-->D[字节码文件*.class]
      D-->E[类装载器]
      E-->F[字节码校验器]
      F-->G[解释器 JVM的一部分]-->H[OS执行]  
```

JVM运行：类的加载；类的执行
  1. 运行java AppMain（class文件）：系统启动一个jvm进程
  2. jvm找到主函数main()，开始执行
  3. main函数第一条命令是Animal animal = new Animal()，去加载Animal类到方法区 ；（运行时数据区：方法区+堆+栈）
  4. jvm在堆中分配内存，创建animal实例，此实例有指向方法区Animal类的类型信息（方法表、动态绑定的底层实现）
  5. 当使用animal.printName(), jvm根据对象引用定位到此类的方法表，获取该函数的字节码地址；
  6. 执行该函数

## python

和java有点类似，最大区别是python是动态的，类型信息在对象上

先编译成字节码，后解释执行

编译：将源文件转为字节码。编译结果也就是 PyCodeObject 对象，只会存在于内存中，**而某个模块的 Python 代码执行完后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中**

一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。

magic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错

Python 是怎么实现动态类型的呢？

  答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。

  因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 “1” + “2” 的结果是不一样的。

## 动态语言

动态性具有以下几个方面的性质：

- 运行时类型检查和绑定：允许变量在运行时根据上下文动态确定类型。
- 动态代码执行：允许在运行时动态加载、编译和执行代码。

Java本身是一种静态类型语言，但它在一定程度上具有动态性。Java的动态性主要通过反射（Reflection）和动态代理（Dynamic Proxy）来实现。反射允许程序在运行时检查对象并调用其方法，而动态代理使得可以在运行时创建代理类来处理对实际对象的调用，从而实现对对象的动态控制。这些机制使得Java在一定程度上具有动态性。





# 链接

**汇编之后才有链接**

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202402041030788.png)

## 静态链接

- 静态链接会造成硬盘与内存的空间浪费
- 静态链接程序的更新困难，已经被链接好了，更新的话需要全部更新

![](https://gitee.com/wanglongxin666/pictures/raw/master/img/202402041031206.png)


## 动态链接

动态链接的原理就是把程序的模块分割开来，使之成为一个个相互独立的文件，并一直保持这种状态，直到程序被加载到内存中运行

**把链接过程推迟到运行时进行的思想就是动态链接的基本原理**


